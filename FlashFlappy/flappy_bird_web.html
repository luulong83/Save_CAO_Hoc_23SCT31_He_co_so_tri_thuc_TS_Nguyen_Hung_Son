<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>
  <style>
    body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
    canvas { border: 1px solid black; }
  </style>
</head>
<body>
  <script>
    let bird;
    let pipes = [];
    let frameCount = 0;
    let score = 0;
    let model;

    // Thiết lập môi trường
    async function setup() {
      createCanvas(400, 600);
      bird = new Bird();
      pipes.push(new Pipe());
      // Tải mô hình DQN đã huấn luyện
      model = await tf.loadLayersModel('http://localhost:8000/flappy_dqn_model_1000.h5');
    }

    // Lớp Bird
    class Bird {
      constructor() {
        this.y = height / 2;
        this.x = 64;
        this.velocity = 0;
        this.gravity = 0.6;
      }

      show() {
        fill(255, 255, 0); // Đầu chim màu vàng
        ellipse(this.x, this.y, 32, 32);
        // Thân chim không vẽ riêng để đơn giản, chỉ dùng màu vàng cho đầu
      }

      update() {
        this.velocity += this.gravity;
        this.y += this.velocity;
        if (this.y > height) this.y = height;
        if (this.y < 0) this.y = 0;
      }

      jump() {
        this.velocity = -10;
      }
    }

    // Lớp Pipe
    class Pipe {
      constructor() {
        this.top = random(height / 2);
        this.bottom = random(height / 2);
        this.x = width;
        this.w = 50;
        this.speed = 2;
      }

      show() {
        fill(0, 255, 0); // Ống màu xanh
        rect(this.x, 0, this.w, this.top);
        rect(this.x, this.top + 150, this.w, height - this.top - 150);
      }

      update() {
        this.x -= this.speed;
      }

      offscreen() {
        return this.x < -this.w;
      }

      hits(bird) {
        if (bird.y < this.top || bird.y > this.top + 150) {
          if (bird.x > this.x && bird.x < this.x + this.w) {
            return true;
          }
        }
        return false;
      }
    }

    // Vẽ và cập nhật
    function draw() {
      background(0);
      bird.update();
      bird.show();

      if (frameCount % 100 === 0) {
        pipes.push(new Pipe());
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].show();
        pipes[i].update();
        if (pipes[i].hits(bird)) {
          console.log("Game Over, Score: ", score);
          bird.y = height / 2;
          pipes = [];
          score = 0;
        }
        if (pipes[i].offscreen()) {
          pipes.splice(i, 1);
        }
        if (pipes[i].x + pipes[i].w < bird.x && !pipes[i].passed) {
          score++;
          pipes[i].passed = true;
          console.log("Score: ", score);
        }
      }

      // DQN Logic
      let state = tf.tensor2d([[bird.y / height, pipes[0]?.x / width || 1, pipes[0]?.top / height || 0.5, bird.velocity / 10]]);
      let action = model.predict(state).argMax().dataSync()[0];
      if (action === 1) bird.jump();

      frameCount++;
    }
  </script>
</body>
</html>